#!/usr/bin/env python3
"""Batch fine cropping utility for license plates."""
from __future__ import annotations

import argparse
import csv
from collections import Counter
from pathlib import Path
from typing import Dict, List, Optional, Sequence

import cv2

# --- add project root to sys.path (bootstrap) ---
import sys
ROOT = Path(__file__).resolve().parents[1]  # <repo-root>/project1
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))
# ------------------------------------------------

from src.plates.plate_cropper import PlateCropError, crop_tail_and_plate

try:  # pragma: no cover - optional dependency
    from src.plates.plate_det import PlateDetector as FinePlateDetector
except Exception:  # pragma: no cover - detector is optional
    FinePlateDetector = None  # type: ignore


def _str_path(value: str) -> str:
    return str(Path(value).as_posix())


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Two-stage plate cropping helper")
    parser.add_argument("--csv", required=True, help="Path to the CSV file generated by run.py")
    parser.add_argument(
        "--outputs-root",
        default="data/outputs",
        help="Root directory containing per-video outputs (default: data/outputs)",
    )
    parser.add_argument("--margin", type=float, default=0.12, help="Secondary crop margin ratio")
    parser.add_argument("--min-height", type=int, default=64, help="Minimum fine crop height")
    parser.add_argument("--aspect-min", type=float, default=2.0, help="Minimum aspect ratio")
    parser.add_argument("--aspect-max", type=float, default=5.0, help="Maximum aspect ratio")
    parser.add_argument("--redetect", action="store_true", help="Re-run plate detector on tail crop")
    parser.add_argument("--plate-imgsz", type=int, default=640, help="Redetect inference size")
    parser.add_argument(
        "--weights",
        default="weights/plate/yolov8n-plate.pt",
        help="YOLO weights for redetection (only used with --redetect)",
    )
    parser.add_argument("--force", action="store_true", help="Reprocess even when outputs exist")
    parser.add_argument(
        "--debug-draw",
        action="store_true",
        help="Save debug visualisations with crop boxes",
    )
    return parser.parse_args(argv)


def _load_csv(csv_path: Path) -> tuple[List[Dict[str, str]], List[str]]:
    rows: List[Dict[str, str]] = []
    with csv_path.open("r", newline="", encoding="utf-8") as fh:
        reader = csv.DictReader(fh)
        header = list(reader.fieldnames or [])
        for row in reader:
            rows.append(dict(row))
    return rows, header


def _save_csv(csv_path: Path, rows: List[Dict[str, str]], header: Sequence[str]) -> None:
    with csv_path.open("w", newline="", encoding="utf-8") as fh:
        writer = csv.DictWriter(fh, fieldnames=list(header))
        writer.writeheader()
        for row in rows:
            writer.writerow(row)


def _parse_bbox(value: str) -> Optional[List[int]]:
    cleaned = (value or "").replace(" ", "")
    if not cleaned:
        return None
    try:
        numbers = [int(round(float(v))) for v in cleaned.split(",")]
    except Exception:
        return None
    if len(numbers) != 4:
        return None
    if numbers[2] <= numbers[0] or numbers[3] <= numbers[1]:
        return None
    return numbers


def _valid_image(path: Path) -> bool:
    if not path.exists():
        return False
    image = cv2.imread(str(path), cv2.IMREAD_COLOR)
    return image is not None and image.size > 0


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = parse_args(argv)
    csv_path = Path(args.csv).expanduser().resolve()
    if not csv_path.exists():
        raise FileNotFoundError(f"CSV 文件不存在: {csv_path}")

    outputs_root = Path(args.outputs_root).expanduser().resolve()
    if not outputs_root.exists():
        raise FileNotFoundError(f"输出根目录不存在: {outputs_root}")

    rows, header = _load_csv(csv_path)

    plate_model = None
    if args.redetect:
        if FinePlateDetector is None:
            raise RuntimeError("未安装 fine plate detector 依赖，无法执行重检测")
        weights_path = Path(args.weights).expanduser().resolve()
        if not weights_path.exists():
            raise FileNotFoundError(
                f"未找到重检测权重: {weights_path}. 请先下载模型到该路径。"
            )
        plate_model = FinePlateDetector(
            weights=str(weights_path),
            conf=0.25,
            imgsz=int(args.plate_imgsz),
            margin=float(args.margin),
            device="cpu",
        )

    stats = Counter()
    failures: Counter[str] = Counter()
    debug_dir = outputs_root / "plates_fine" / "_debug_crops"

    for row in rows:
        track_id = row.get("track_id", "?")
        bbox = _parse_bbox(row.get("plate_bbox_xyxy", ""))
        best_frame_rel = row.get("best_frame_img", "").strip()
        if not bbox or not best_frame_rel:
            stats["skipped"] += 1
            row["fine_img"] = ""
            continue

        frame_path = outputs_root / Path(best_frame_rel)
        if not frame_path.exists():
            stats["failed"] += 1
            reason = f"frame_missing:{frame_path.name}"
            failures[reason] += 1
            row["fine_img"] = ""
            print(f"[WARN] track_id={track_id} 缺少最佳帧: {frame_path}")
            continue

        base_name = Path(best_frame_rel).stem
        tail_rel = Path("plates") / f"{base_name}_tail.jpg"
        fine_rel = Path("plates_fine") / f"{base_name}_best_plate.jpg"
        tail_path = outputs_root / tail_rel
        fine_path = outputs_root / fine_rel

        if not args.force and row.get("fine_img"):
            existing = outputs_root / Path(row["fine_img"])
            if _valid_image(existing):
                stats["skipped"] += 1
                continue

        try:
            result = crop_tail_and_plate(
                frame_path=frame_path,
                bbox_xyxy=bbox,
                margin=float(args.margin),
                out_tail_path=tail_path,
                out_plate_path=fine_path,
                redetect=args.redetect,
                plate_model=plate_model,
                min_h=int(args.min_height),
                aspect_range=(float(args.aspect_min), float(args.aspect_max)),
                debug_draw=bool(args.debug_draw),
                debug_dir=debug_dir,
            )
        except PlateCropError as exc:
            stats["failed"] += 1
            failures[str(exc)] += 1
            row["fine_img"] = ""
            print(f"[WARN] track_id={track_id} 裁剪失败: {exc}")
            continue

        row["tail_img"] = _str_path(tail_rel)
        row["fine_img"] = _str_path(fine_rel)
        stats["processed"] += 1
        print(
            f"[OK] track_id={track_id} fine={fine_rel} size={result['w']}x{result['h']}"
        )

    if header:
        header = list(dict.fromkeys(list(header) + ["tail_img", "fine_img"]))
    else:
        header = ["track_id", "tail_img", "fine_img"]
    _save_csv(csv_path, rows, header)

    print("--- Summary ---")
    for key in ("processed", "skipped", "failed"):
        print(f"{key}: {stats.get(key, 0)}")
    if failures:
        print("Top failure reasons:")
        for reason, count in failures.most_common(3):
            print(f"  {reason}: {count}")
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
